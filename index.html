<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>CineFlow V9 | DoP POV Storyboard</title>

  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/js/all.min.js"></script>
  <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>

  <!-- ZIP download (Download All storyboard frames) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>

  <style>
    :root{
      --bg-color:#0d0d0d;
      --grid-color:rgba(255,255,255,0.03);
      --glass-bg:rgba(20,20,20,0.85);
      --glass-border:rgba(255,255,255,0.08);
      --brand:#ffa300;
      --text-color:#eeeeee;
      --shadow: rgba(0,0,0,0.35);
    }
    body.light-mode{
      --bg-color:#f0f0f0;
      --grid-color:rgba(0,0,0,0.06);
      --glass-bg:rgba(255,255,255,0.90);
      --glass-border:rgba(0,0,0,0.10);
      --brand:#ffa300;
      --text-color:#1a1a1a;
      --shadow: rgba(0,0,0,0.12);
    }

    body{
      background:var(--bg-color);
      color:var(--text-color);
      margin:0;
      overflow:hidden;
      touch-action:none;
      font-family:-apple-system,BlinkMacSystemFont,"SF Pro Text","Segoe UI",Roboto,sans-serif;
      user-select:none; -webkit-user-select:none;
      transition: background-color .25s;
    }

    #viewport{ width:100vw; height:100vh; position:relative; overflow:hidden; cursor:grab; }
    #world{ position:absolute; top:0; left:0; width:100%; height:100%; transform-origin:0 0; pointer-events:none; }
    #world > *{ pointer-events:auto; }

    #grid-pattern{
      position:absolute; top:-5000px; left:-5000px; width:10000px; height:10000px;
      background-image:
        linear-gradient(var(--grid-color) 1px, transparent 1px),
        linear-gradient(90deg, var(--grid-color) 1px, transparent 1px);
      background-size:50px 50px;
      pointer-events:none; z-index:-1;
    }

    svg.path-layer{
      position:absolute; top:-5000px; left:-5000px; width:10000px; height:10000px;
      pointer-events:none; z-index:0; overflow:visible;
    }

    .glass-panel{
      background:var(--glass-bg);
      backdrop-filter: blur(24px);
      -webkit-backdrop-filter: blur(24px);
      border:1px solid var(--glass-border);
      color:var(--text-color);
      box-shadow:0 8px 32px var(--shadow);
    }

    .text-brand{ color:var(--brand); }
    .bg-brand{ background-color:var(--brand); }
    .border-brand{ border-color:var(--brand); }

    .scene-object{
      position:absolute;
      transform-origin:center center;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      cursor:grab;
      z-index:10;
      will-change: transform, left, top;
    }
    .scene-object.ghost{ opacity:.42; filter:grayscale(100%); z-index:5; }
    .scene-object.hidden-layer{ opacity:.18; pointer-events:none; }

    .scene-object.selected .object-visual{
      outline:2px solid var(--brand);
      box-shadow:0 0 25px rgba(255,163,0,0.30);
    }

    .control-handle{
      position:absolute; width:20px; height:20px;
      background:white; border-radius:50%;
      color:black;
      box-shadow:0 2px 5px rgba(0,0,0,0.30);
      display:flex; align-items:center; justify-content:center;
      font-size:8px;
      z-index:20;
      transform:scale(0);
      transition: transform .2s cubic-bezier(0.175,0.885,0.32,1.275);
    }
    .selected .control-handle{ transform:scale(1); }
    .rotate-handle{ top:-30px; cursor:pointer; }
    .resize-handle{ bottom:-15px; right:-15px; cursor:se-resize; }

    .object-visual{ transition: transform .08s; }

    .fov-cone{
      position:absolute; bottom:50%; left:50%;
      transform: translateX(-50%);
      width:0; height:0;
      border-left:120px solid transparent;
      border-right:120px solid transparent;
      border-top:300px solid rgba(255,163,0,0.15);
      pointer-events:none;
      transform-origin: bottom center;
    }

    .cam-body{
      width:36px; height:24px; background:var(--brand);
      border-radius:6px; position:relative; z-index:2;
    }

    .prop-visual{
      display:flex; align-items:center; justify-content:center;
      color:var(--text-color); border:1px solid rgba(255,255,255,0.15);
    }

    .measurement-line{
      stroke: var(--brand);
      stroke-width: 1;
      stroke-dasharray: 2,2;
      opacity: .65;
    }
    .measurement-text{
      fill: var(--brand);
      font-size: 10px;
      font-weight: 700;
    }

    .layer-badge{
      position:absolute;
      top:-8px; right:-8px;
      width:16px; height:16px;
      border-radius:50%;
      background:var(--brand);
      color:black;
      font-size:8px;
      font-weight:800;
      display:flex; align-items:center; justify-content:center;
      z-index:25; pointer-events:none;
    }

    @keyframes fadeIn{ from{ opacity:0; transform:scale(.96);} to{opacity:1; transform:scale(1);} }
    .animate-in{ animation: fadeIn .18s cubic-bezier(.16,1,.3,1); }
    .hide-scroll::-webkit-scrollbar{ display:none; }

    /* ===== Mobile icon fix: toolbar scroll ===== */
    .edge-fade{
      -webkit-mask-image: linear-gradient(to right, transparent, black 18px, black calc(100% - 18px), transparent);
              mask-image: linear-gradient(to right, transparent, black 18px, black calc(100% - 18px), transparent);
    }
    .touch-scroll{ -webkit-overflow-scrolling: touch; }

    /* Storyboard */
    .storyboard-frame{
      aspect-ratio:16/9;
      border:2px solid var(--glass-border);
      border-radius:14px;
      overflow:hidden;
      background: rgba(0,0,0,0.25);
    }
    canvas.pov-canvas{
      width:100%;
      height:100%;
      display:block;
      background:#111;
    }
  </style>
</head>

<body>
  <div id="viewport">
    <div id="world">
      <div id="grid-pattern"></div>
      <svg id="svg-layer" class="path-layer"></svg>
      <svg id="measurement-layer" class="path-layer"></svg>
    </div>
  </div>

  <!-- ===== TOP BAR (responsive + scroll su mobile) ===== -->
  <div class="fixed top-0 left-0 w-full p-4 pointer-events-none z-50">
    <div class="flex flex-col sm:flex-row sm:justify-between gap-3">
      <!-- Left group -->
      <div class="pointer-events-auto w-full sm:w-auto">
        <div class="flex items-center gap-3 overflow-x-auto hide-scroll edge-fade touch-scroll px-1">
          <button data-action="toggleSceneMenu"
                  class="flex-none glass-panel px-4 py-2.5 rounded-2xl flex items-center gap-3 hover:bg-white/5 transition group"
                  aria-label="Apri project manager" title="Project manager">
            <i class="fa-solid fa-film text-brand text-xs"></i>
            <span class="text-[10px] font-bold uppercase tracking-widest opacity-80" id="scene-name-display">Untitled</span>
          </button>

          <button data-action="createNewScene"
                  class="flex-none glass-panel w-10 h-10 rounded-2xl flex items-center justify-center hover:text-brand transition"
                  aria-label="Nuova scena" title="Nuova scena">
            <i class="fa-solid fa-plus text-xs"></i>
          </button>

          <button data-action="undo" id="undo-btn"
                  class="flex-none glass-panel w-10 h-10 rounded-2xl flex items-center justify-center hover:text-brand transition opacity-40"
                  disabled aria-label="Annulla" title="Annulla (Ctrl/Cmd+Z)">
            <i class="fa-solid fa-undo text-xs"></i>
          </button>

          <button data-action="redo" id="redo-btn"
                  class="flex-none glass-panel w-10 h-10 rounded-2xl flex items-center justify-center hover:text-brand transition opacity-40"
                  disabled aria-label="Ripeti" title="Ripeti (Ctrl/Cmd+Shift+Z)">
            <i class="fa-solid fa-redo text-xs"></i>
          </button>
        </div>
      </div>

      <!-- Right group (icons) -->
      <div class="pointer-events-auto w-full sm:w-auto">
        <div class="flex items-center gap-3 overflow-x-auto hide-scroll edge-fade touch-scroll px-1">
          <button data-action="toggleSnap" id="snap-btn"
                  class="flex-none glass-panel w-11 h-11 rounded-2xl flex items-center justify-center hover:text-brand transition"
                  aria-label="Snap alla griglia" title="Snap">
            <i class="fa-solid fa-magnet text-xs"></i>
          </button>

          <button data-action="toggleMeasurements" id="measure-btn"
                  class="flex-none glass-panel w-11 h-11 rounded-2xl flex items-center justify-center hover:text-brand transition"
                  aria-label="Misure" title="Misure">
            <i class="fa-solid fa-ruler text-xs"></i>
          </button>

          <button data-action="toggleLayers"
                  class="flex-none glass-panel w-11 h-11 rounded-2xl flex items-center justify-center hover:text-brand transition"
                  aria-label="Layer" title="Layer">
            <i class="fa-solid fa-layer-group text-xs"></i>
          </button>

          <button data-action="exportStoryboard"
                  class="flex-none glass-panel w-11 h-11 rounded-2xl flex items-center justify-center hover:text-brand transition"
                  aria-label="Storyboard" title="Storyboard">
            <i class="fa-solid fa-th text-xs"></i>
          </button>

          <button data-action="playScene" id="play-btn"
                  class="flex-none glass-panel px-6 py-3 rounded-2xl flex items-center gap-2 text-[10px] font-extrabold text-brand border border-brand/20 hover:bg-brand/10 transition"
                  aria-label="Action" title="ACTION">
            <i class="fa-solid fa-play"></i> ACTION
          </button>

          <button data-action="takeSnapshot"
                  class="flex-none glass-panel w-11 h-11 rounded-2xl flex items-center justify-center hover:text-brand transition"
                  aria-label="Snapshot" title="Snapshot">
            <i class="fa-solid fa-camera text-xs"></i>
          </button>

          <button data-action="openProjectSettings"
                  class="flex-none glass-panel w-11 h-11 rounded-2xl flex items-center justify-center hover:text-brand transition"
                  aria-label="Impostazioni progetto" title="Impostazioni">
            <i class="fa-solid fa-gear text-xs"></i>
          </button>

          <a href="https://forms.gle/VCnSQXX6EtNc66Hp6" target="_blank"
             class="flex-none glass-panel w-11 h-11 rounded-2xl flex items-center justify-center bg-brand/10 text-brand border border-brand/20 hover:bg-brand hover:text-black transition"
             aria-label="Feedback" title="Feedback">
            <i class="fa-regular fa-comment-dots text-xs"></i>
          </a>
        </div>
      </div>
    </div>
  </div>

  <!-- ===== BOTTOM TOOLBAR (actor/cam/prop) ===== -->
  <div class="fixed left-1/2 -translate-x-1/2 glass-panel rounded-full p-2.5 flex gap-4 shadow-2xl z-50 scale-90 sm:scale-100 border-t border-white/10 pointer-events-auto"
       style="bottom: calc(2.5rem + env(safe-area-inset-bottom));">
    <button data-action="addActor" class="flex flex-col items-center justify-center w-16 h-16 rounded-3xl hover:bg-white/5 active:scale-95 transition group"
            aria-label="Aggiungi attore" title="Actor">
      <div class="w-4 h-4 rounded-full bg-rose-500 mb-2 shadow-[0_0_15px_rgba(244,63,94,0.4)] group-hover:scale-110 transition"></div>
      <span class="text-[9px] font-bold opacity-60 group-hover:opacity-100 group-hover:text-rose-400">ACTOR</span>
    </button>
    <div class="w-px h-8 bg-white/5 my-auto"></div>
    <button data-action="addCamera" class="flex flex-col items-center justify-center w-16 h-16 rounded-3xl hover:bg-white/5 active:scale-95 transition group"
            aria-label="Aggiungi camera" title="Camera">
      <div class="w-6 h-4 rounded bg-brand mb-2 shadow-[0_0_15px_rgba(255,163,0,0.4)] group-hover:scale-110 transition"></div>
      <span class="text-[9px] font-bold opacity-60 group-hover:opacity-100 text-brand">CAM</span>
    </button>
    <div class="w-px h-8 bg-white/5 my-auto"></div>
    <button data-action="openPropPicker" class="flex flex-col items-center justify-center w-16 h-16 rounded-3xl hover:bg-white/5 active:scale-95 transition group"
            aria-label="Aggiungi prop" title="Prop">
      <div class="w-4 h-4 border border-white/50 mb-2 group-hover:scale-110 transition"></div>
      <span class="text-[9px] font-bold opacity-60 group-hover:opacity-100">PROP</span>
    </button>
  </div>

  <!-- ===== EDIT BAR ===== -->
  <div id="edit-bar" class="fixed left-1/2 -translate-x-1/2 glass-panel px-6 py-3 rounded-full hidden items-center gap-8 z-50 shadow-2xl animate-in"
       style="bottom: calc(8rem + env(safe-area-inset-bottom));">
    <button data-action="openInspector" class="text-[9px] font-bold hover:text-brand flex flex-col items-center gap-1.5 transition" aria-label="Edit">
      <i class="fa-solid fa-sliders text-sm"></i>EDIT
    </button>
    <div class="w-px h-6 bg-white/10"></div>
    <button data-action="addGhostPath" class="text-[9px] font-bold hover:text-green-400 flex flex-col items-center gap-1.5 transition" aria-label="Step">
      <i class="fa-solid fa-shoe-prints text-sm"></i>STEP
    </button>
    <div class="w-px h-6 bg-white/10"></div>
    <button data-action="deleteSelected" class="text-[9px] font-bold hover:text-red-400 flex flex-col items-center gap-1.5 transition" aria-label="Delete">
      <i class="fa-solid fa-trash text-sm"></i>DEL
    </button>
  </div>

  <!-- ===== INSPECTOR ===== -->
  <div id="inspector" class="fixed right-6 top-1/2 -translate-y-1/2 w-80 glass-panel rounded-[32px] p-6 translate-x-[150%] transition-transform duration-300 shadow-2xl z-50 border-l border-white/10">
    <div class="flex justify-between items-center mb-8">
      <h2 class="text-xs font-bold opacity-40 uppercase tracking-[0.2em]">Settings</h2>
      <button data-action="closeInspector" class="opacity-50 hover:opacity-100 hover:text-brand transition" aria-label="Chiudi inspector" title="Chiudi">
        <i class="fa-solid fa-xmark text-lg"></i>
      </button>
    </div>

    <div class="mb-6">
      <label class="text-[9px] uppercase font-bold opacity-40 mb-2 block tracking-wider">Identity</label>
      <input type="text" id="insp-name" class="w-full bg-white/5 border border-white/10 rounded-xl p-3 text-xs focus:border-brand outline-none transition font-medium" />
    </div>

    <div class="mb-6">
      <label class="text-[9px] uppercase font-bold opacity-40 mb-2 block tracking-wider">Layer</label>
      <select id="insp-layer" class="w-full bg-white/5 border border-white/10 rounded-xl p-3 text-xs focus:border-brand outline-none transition">
        <option value="1">Layer 1</option>
        <option value="2">Layer 2</option>
        <option value="3">Layer 3</option>
      </select>
    </div>

    <!-- Camera controls -->
    <div id="cam-controls" class="hidden mb-6 p-4 bg-brand/5 border border-brand/20 rounded-2xl">
      <div class="flex items-center gap-2 mb-3 text-brand">
        <i class="fa-solid fa-video text-xs"></i>
        <span class="text-[9px] font-bold uppercase tracking-wider">Lens & Sensor</span>
      </div>

      <div class="grid grid-cols-2 gap-3 mb-3">
        <div>
          <label class="text-[9px] uppercase font-bold opacity-40 mb-2 block tracking-wider">Sensor</label>
          <select id="sensor-select" class="w-full bg-white/5 border border-white/10 rounded-xl p-3 text-xs focus:border-brand outline-none transition">
            <option value="FF">Full Frame (36×24)</option>
            <option value="S35">Super 35 (24.89×18.66)</option>
            <option value="MFT">Micro 4/3 (17.3×13.0)</option>
          </select>
        </div>
        <div>
          <label class="text-[9px] uppercase font-bold opacity-40 mb-2 block tracking-wider">Focale (mm)</label>
          <input id="focal-input" type="number" min="8" max="300" step="1"
                 class="w-full bg-white/5 border border-white/10 rounded-xl p-3 text-xs focus:border-brand outline-none transition"
                 value="35" />
        </div>
      </div>

      <div class="flex items-center justify-between text-[10px] opacity-80 mb-3">
        <div>HFOV: <span id="hfov-readout" class="text-brand font-bold">–</span></div>
        <div>VFOV: <span id="vfov-readout" class="text-brand font-bold">–</span></div>
      </div>

      <div class="flex items-center gap-2 mb-3 text-brand">
        <i class="fa-solid fa-crosshairs text-xs"></i>
        <span class="text-[9px] font-bold uppercase tracking-wider">Tracking</span>
      </div>
      <button data-action="activateTargetMode" id="target-btn" class="w-full py-3 bg-brand/10 hover:bg-brand hover:text-black border border-brand/30 rounded-xl text-[10px] font-bold text-brand transition mb-3">
        LINK TO ACTOR
      </button>
      <div id="target-status" class="hidden mb-3 text-[9px] text-center text-brand opacity-80">
        <i class="fa-solid fa-link mr-1"></i> Locked to <span id="target-name" class="font-bold border-b border-brand/30">Target</span>
      </div>

      <div class="text-[9px] uppercase font-bold opacity-40 mb-2 block tracking-wider">Override FOV (opzionale)</div>
      <input type="range" id="fov-slider" min="20" max="120" value="60" class="w-full" />
      <div class="text-[8px] text-center text-brand mt-1"><span id="fov-value">60</span>°</div>
    </div>

    <!-- Style -->
    <div class="mb-8">
      <label class="text-[9px] uppercase font-bold opacity-40 mb-3 block tracking-wider">Style</label>
      <div class="flex gap-3 items-center">
        <div class="relative group">
          <div class="w-8 h-8 rounded-full bg-gradient-to-br from-gray-700 to-gray-900 border border-white/20 flex items-center justify-center cursor-pointer group-hover:border-brand transition">
            <i class="fa-solid fa-palette text-[10px] text-white/50 group-hover:text-brand"></i>
          </div>
          <input id="color-picker" type="color" class="absolute inset-0 opacity-0 cursor-pointer w-full h-full" />
        </div>
        <div class="w-px h-6 bg-white/10"></div>
        <button data-color="#ffa300" class="w-6 h-6 rounded-full bg-[#ffa300] ring-2 ring-transparent hover:ring-white/30 transition hover:scale-110" aria-label="Colore arancio"></button>
        <button data-color="#f43f5e" class="w-6 h-6 rounded-full bg-[#f43f5e] ring-2 ring-transparent hover:ring-white/30 transition hover:scale-110" aria-label="Colore rosa"></button>
        <button data-color="#0ea5e9" class="w-6 h-6 rounded-full bg-[#0ea5e9] ring-2 ring-transparent hover:ring-white/30 transition hover:scale-110" aria-label="Colore azzurro"></button>
      </div>
    </div>

    <div class="grid grid-cols-2 gap-3 pt-6 border-t border-white/5">
      <button data-action="addGhostPath" class="col-span-2 py-3 bg-white/5 border border-white/10 rounded-xl text-[10px] font-bold hover:bg-white/10 hover:border-white/20 flex items-center justify-center gap-2 transition text-brand">
        <i class="fa-solid fa-shoe-prints"></i> ADD STEP
      </button>
      <button data-action="deleteSelected" class="col-span-2 py-3 bg-red-500/5 border border-red-500/10 text-red-400 text-[10px] font-bold rounded-xl hover:bg-red-500/10 transition">
        DELETE
      </button>
    </div>
  </div>

  <!-- ===== SCENE MENU ===== -->
  <div id="scene-menu" class="fixed inset-0 bg-black/90 z-[70] hidden flex items-center justify-center backdrop-blur-md animate-in">
    <div class="glass-panel w-80 rounded-3xl p-8 relative border-t border-white/10">
      <h2 class="text-xs font-bold uppercase tracking-[0.2em] mb-6 text-brand text-center">Project Manager</h2>
      <div class="mb-6 flex gap-2">
        <input type="text" id="scene-name-input" class="flex-1 bg-white/5 border border-white/10 rounded-xl p-3 text-xs focus:border-brand outline-none transition"
               placeholder="Nome scena..." aria-label="Nome scena">
        <button data-action="saveScene" class="bg-brand text-black px-5 rounded-xl text-xs font-bold hover:opacity-90 transition shadow-lg shadow-brand/20"
                aria-label="Salva scena" title="Salva">SAVE</button>
      </div>
      <div class="text-[9px] uppercase opacity-40 font-bold mb-3 tracking-widest">Saved Scenes</div>
      <div id="saved-list" class="max-h-60 overflow-y-auto space-y-2 pr-1 hide-scroll"></div>
    </div>
  </div>

  <!-- ===== PROPS ===== -->
  <div id="prop-picker" class="fixed inset-0 bg-black/90 z-[60] hidden flex items-center justify-center backdrop-blur-md animate-in">
    <div class="glass-panel w-[90vw] max-w-md h-[70vh] rounded-[32px] overflow-hidden flex flex-col border border-white/10">
      <div class="p-6 border-b border-white/5">
        <h3 class="text-xs font-bold uppercase tracking-[0.2em] text-brand">Prop Warehouse</h3>
      </div>
      <div class="p-3 flex gap-3 overflow-x-auto border-b border-white/5 hide-scroll bg-black/20">
        <button data-prop-cat="light" class="px-4 py-1.5 bg-brand text-black rounded-full text-[10px] font-bold shadow-lg shadow-brand/20">Lighting</button>
        <button data-prop-cat="furniture" class="px-4 py-1.5 bg-white/5 hover:bg-white/10 rounded-full text-[10px] font-medium transition">Furniture</button>
        <button data-prop-cat="set" class="px-4 py-1.5 bg-white/5 hover:bg-white/10 rounded-full text-[10px] font-medium transition">Set Pieces</button>
      </div>
      <div id="prop-grid" class="p-6 overflow-y-auto grid grid-cols-4 gap-4 content-start hide-scroll"></div>
    </div>
  </div>

  <!-- ===== LAYERS ===== -->
  <div id="layers-panel" class="fixed left-6 top-1/2 -translate-y-1/2 w-64 glass-panel rounded-3xl p-6 -translate-x-[150%] transition-transform duration-300 shadow-2xl z-50 border-r border-white/10">
    <div class="flex justify-between items-center mb-6">
      <h2 class="text-xs font-bold opacity-40 uppercase tracking-[0.2em]">Layers</h2>
      <button data-action="toggleLayers" class="opacity-50 hover:opacity-100 hover:text-brand transition" aria-label="Chiudi layers" title="Chiudi">
        <i class="fa-solid fa-xmark text-lg"></i>
      </button>
    </div>

    <div class="space-y-2">
      <div class="flex items-center gap-3 p-3 bg-white/5 rounded-xl hover:bg-white/10 transition cursor-pointer" data-action="toggleLayerVisibility" data-layer="1">
        <div class="w-6 h-6 rounded-full bg-brand flex items-center justify-center text-black text-[10px] font-bold">1</div>
        <span class="text-xs font-medium flex-1">Layer 1</span>
        <i class="fa-solid fa-eye text-xs opacity-60" id="layer-eye-1"></i>
      </div>
      <div class="flex items-center gap-3 p-3 bg-white/5 rounded-xl hover:bg-white/10 transition cursor-pointer" data-action="toggleLayerVisibility" data-layer="2">
        <div class="w-6 h-6 rounded-full bg-rose-500 flex items-center justify-center text-white text-[10px] font-bold">2</div>
        <span class="text-xs font-medium flex-1">Layer 2</span>
        <i class="fa-solid fa-eye text-xs opacity-60" id="layer-eye-2"></i>
      </div>
      <div class="flex items-center gap-3 p-3 bg-white/5 rounded-xl hover:bg-white/10 transition cursor-pointer" data-action="toggleLayerVisibility" data-layer="3">
        <div class="w-6 h-6 rounded-full bg-sky-500 flex items-center justify-center text-white text-[10px] font-bold">3</div>
        <span class="text-xs font-medium flex-1">Layer 3</span>
        <i class="fa-solid fa-eye text-xs opacity-60" id="layer-eye-3"></i>
      </div>
    </div>
  </div>

  <!-- ===== PROJECT SETTINGS (scale + storyboard) ===== -->
  <div id="project-settings" class="fixed inset-0 bg-black/80 z-[75] hidden items-center justify-center backdrop-blur-md animate-in">
    <div class="glass-panel w-[92vw] max-w-lg rounded-3xl p-8 border border-white/10">
      <div class="flex justify-between items-center mb-6">
        <h3 class="text-xs font-bold uppercase tracking-[0.2em] text-brand">Impostazioni progetto</h3>
        <button data-action="closeProjectSettings" class="opacity-60 hover:opacity-100 hover:text-brand" aria-label="Chiudi">
          <i class="fa-solid fa-xmark"></i>
        </button>
      </div>

      <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 mb-6">
        <div class="p-4 rounded-2xl bg-white/5 border border-white/10">
          <div class="text-[9px] uppercase font-bold opacity-50 tracking-wider mb-2">Scala (px per metro)</div>
          <input id="ppm-input" type="number" min="10" max="500" step="5"
                 class="w-full bg-white/5 border border-white/10 rounded-xl p-3 text-xs focus:border-brand outline-none transition"
                 value="100">
          <div class="text-[10px] opacity-60 mt-2">Esempio: 100 px = 1 m</div>
        </div>

        <div class="p-4 rounded-2xl bg-white/5 border border-white/10">
          <div class="text-[9px] uppercase font-bold opacity-50 tracking-wider mb-2">Aspect (letterbox su 16:9)</div>
          <select id="aspect-select" class="w-full bg-white/5 border border-white/10 rounded-xl p-3 text-xs focus:border-brand outline-none transition">
            <option value="2.39">2.39:1 (Cinemascope)</option>
            <option value="1.85">1.85:1</option>
            <option value="1.7777777778">16:9</option>
          </select>
          <label class="flex items-center gap-2 mt-3 text-[10px] opacity-70">
            <input id="overlays-toggle" type="checkbox" checked />
            Mostra overlay (safe/terzi/metadata)
          </label>
        </div>
      </div>

      <button data-action="applyProjectSettings"
              class="w-full bg-brand text-black py-3 rounded-xl text-xs font-bold hover:opacity-90 transition shadow-lg shadow-brand/20">
        APPLICA
      </button>
    </div>
  </div>

  <!-- ===== STORYBOARD MODAL ===== -->
  <div id="storyboard-modal" class="fixed inset-0 bg-black/95 z-[80] hidden items-center justify-center backdrop-blur-lg">
    <div class="glass-panel w-[92vw] max-w-6xl max-h-[90vh] rounded-3xl overflow-hidden flex flex-col border border-white/10">
      <div class="p-6 border-b border-white/5 flex justify-between items-center">
        <div>
          <h3 class="text-xs font-bold uppercase tracking-[0.2em] text-brand">Storyboard Export (POV)</h3>
          <div class="text-[10px] opacity-60 mt-1">Output 16:9 con letterbox + safe areas (come monitor di set).</div>
        </div>
        <button data-action="closeStoryboard" class="opacity-60 hover:opacity-100 hover:text-brand" aria-label="Chiudi storyboard" title="Chiudi">
          <i class="fa-solid fa-xmark"></i>
        </button>
      </div>
      <div class="p-6 overflow-y-auto" id="storyboard-grid"></div>
      <div class="p-6 border-t border-white/5 flex gap-3 justify-end items-center">
        <button data-action="downloadStoryboardZip" class="bg-brand text-black px-6 py-3 rounded-xl text-xs font-bold hover:opacity-90 transition shadow-lg shadow-brand/20">
          <i class="fa-solid fa-download mr-2"></i>DOWNLOAD ALL (ZIP)
        </button>
      </div>
    </div>
  </div>

  <!-- ===== TIMELINE ===== -->
  <div id="timeline-container" class="fixed left-1/2 -translate-x-1/2 w-[min(92vw,600px)] glass-panel rounded-2xl p-4 hidden flex-col gap-3 z-50 shadow-2xl"
       style="bottom: calc(1rem + env(safe-area-inset-bottom));">
    <div class="flex justify-between items-center mb-2">
      <span class="text-[9px] font-bold uppercase tracking-wider opacity-60">Timeline</span>
      <button data-action="closeTimeline" class="text-xs opacity-60 hover:opacity-100 hover:text-brand" aria-label="Chiudi timeline" title="Chiudi">
        <i class="fa-solid fa-xmark"></i>
      </button>
    </div>
    <div class="relative h-2 bg-white/5 rounded-full overflow-hidden cursor-pointer" id="timeline-scrubber">
      <div class="absolute top-1/2 -translate-y-1/2 w-4 h-4 bg-brand rounded-full shadow-lg" id="timeline-playhead" style="left:0;"></div>
    </div>
    <div class="flex justify-between text-[8px] opacity-40">
      <span>0:00</span>
      <span id="timeline-duration">0:00</span>
    </div>
  </div>

<script>
(() => {
  const VERSION = "cf_v9";
  const MAX_HISTORY = 60;
  const GRID_SNAP = 25;

  const SENSOR_DB = {
    FF:  { name: "Full Frame", w: 36.0,   h: 24.0 },
    S35: { name: "Super 35",   w: 24.89,  h: 18.66 },
    MFT: { name: "Micro 4/3",  w: 17.3,   h: 13.0 },
  };

  const el = {
    viewport: document.getElementById("viewport"),
    world: document.getElementById("world"),
    grid: document.getElementById("grid-pattern"),
    svg: document.getElementById("svg-layer"),
    meas: document.getElementById("measurement-layer"),

    sceneMenu: document.getElementById("scene-menu"),
    sceneNameDisplay: document.getElementById("scene-name-display"),
    sceneNameInput: document.getElementById("scene-name-input"),
    savedList: document.getElementById("saved-list"),

    inspector: document.getElementById("inspector"),
    editBar: document.getElementById("edit-bar"),
    camControls: document.getElementById("cam-controls"),
    targetStatus: document.getElementById("target-status"),
    targetName: document.getElementById("target-name"),

    inspName: document.getElementById("insp-name"),
    inspLayer: document.getElementById("insp-layer"),
    fovSlider: document.getElementById("fov-slider"),
    fovValue: document.getElementById("fov-value"),

    sensorSelect: document.getElementById("sensor-select"),
    focalInput: document.getElementById("focal-input"),
    hfovReadout: document.getElementById("hfov-readout"),
    vfovReadout: document.getElementById("vfov-readout"),

    colorPicker: document.getElementById("color-picker"),

    undoBtn: document.getElementById("undo-btn"),
    redoBtn: document.getElementById("redo-btn"),
    playBtn: document.getElementById("play-btn"),

    propPicker: document.getElementById("prop-picker"),
    propGrid: document.getElementById("prop-grid"),

    layersPanel: document.getElementById("layers-panel"),

    timeline: document.getElementById("timeline-container"),
    timelineScrubber: document.getElementById("timeline-scrubber"),
    timelinePlayhead: document.getElementById("timeline-playhead"),
    timelineDuration: document.getElementById("timeline-duration"),

    storyboardModal: document.getElementById("storyboard-modal"),
    storyboardGrid: document.getElementById("storyboard-grid"),

    snapBtn: document.getElementById("snap-btn"),
    measureBtn: document.getElementById("measure-btn"),

    projectSettings: document.getElementById("project-settings"),
    ppmInput: document.getElementById("ppm-input"),
    aspectSelect: document.getElementById("aspect-select"),
    overlaysToggle: document.getElementById("overlays-toggle"),
  };

  const propDB = {
    light: [
      { n: "Skypanel", i: "fa-table-cells", w: 40, h: 25 },
      { n: "Spot", i: "fa-bullseye", w: 25, h: 35 },
      { n: "Tube", i: "fa-grip-lines-vertical", w: 10, h: 50 },
    ],
    furniture: [
      { n: "Chair", i: "fa-chair", w: 30, h: 30 },
      { n: "Table", i: "fa-table", w: 60, h: 40 },
      { n: "Bed", i: "fa-bed", w: 60, h: 80 },
    ],
    set: [
      { n: "Wall", i: "fa-square", w: 100, h: 10 },
      { n: "Window", i: "fa-border-all", w: 60, h: 5 },
    ],
  };

  const state = {
    view: { panX: 0, panY: 0, scale: 1 },
    objects: [],
    selectedId: null,

    layerVisibility: { 1: true, 2: true, 3: true },
    measurementsEnabled: false,
    snapEnabled: false,

    targetMode: false,

    // Project units
    pxPerMeter: 100,       // default: 100 px = 1 m
    actorHeightM: 1.70,    // used for shot-size estimate

    // Storyboard settings
    storyboard: {
      aspect: 2.39,        // default for DoP
      overlays: true
    },

    // animation
    isAnimating: false,
    animationProgress: 0,
    animationDuration: 0,
    animationStartTime: 0,
    animationInitialPositions: new Map(),
    animationTimelines: [],

    // undo/redo
    history: [],
    historyIndex: -1,

    // pointers
    pointers: new Map(),
    pinch: { initialDist: 0, initialScale: 1, mid: {x:0,y:0}, initialPan: {x:0,y:0} },

    // perf flags
    needsRender: true,
    needsLines: true,
    needsMeasurements: true,

    // scene
    sceneName: "Untitled",
  };

  // ---------- Helpers ----------
  const clamp = (v, a, b) => Math.min(Math.max(v, a), b);
  const uid = () => "obj_" + Date.now() + Math.random().toString(16).slice(2);

  function worldToScreen(x, y){
    const {panX, panY, scale} = state.view;
    return { x: x*scale + panX, y: y*scale + panY };
  }
  function screenToWorld(x, y){
    const {panX, panY, scale} = state.view;
    return { x: (x - panX)/scale, y: (y - panY)/scale };
  }

  function normalizeKeyName(name){
    return name.trim().replace(/\s+/g, " ").slice(0, 60);
  }
  function storageKey(name){ return `${VERSION}::scene::${normalizeKeyName(name)}`; }

  function getObject(id){ return state.objects.find(o => o.id === id) || null; }

  function sanitizeLabel(s){
    const t = (s ?? "").toString().trim();
    return t.length ? t.slice(0, 30) : "";
  }

  function forwardVector(rotDeg){
    const rad = rotDeg * Math.PI/180;
    return { fx: Math.sin(rad), fy: -Math.cos(rad) }; // 0° = up
  }

  function computeFovDegrees(sensorKey, focalMm){
    const s = SENSOR_DB[sensorKey] || SENSOR_DB.FF;
    const f = Math.max(1, Number(focalMm) || 35);
    const hfov = 2 * Math.atan((s.w) / (2*f)) * 180/Math.PI;
    const vfov = 2 * Math.atan((s.h) / (2*f)) * 180/Math.PI;
    return { hfov, vfov };
  }

  function markDirty({render=false, lines=false, meas=false} = {}){
    if(render) state.needsRender = true;
    if(lines) state.needsLines = true;
    if(meas) state.needsMeasurements = true;
    requestTick();
  }

  let rafPending = false;
  function requestTick(){
    if(rafPending) return;
    rafPending = true;
    requestAnimationFrame(tick);
  }

  function tick(){
    rafPending = false;

    if(state.needsRender){
      renderObjectsDOM();
      state.needsRender = false;
    }
    if(state.needsLines){
      drawConnections();
      state.needsLines = false;
    }
    if(state.measurementsEnabled && state.needsMeasurements){
      drawMeasurements();
      state.needsMeasurements = false;
    }
    updateTrackingRotationsIfNeeded();
  }

  // ---------- View (pan/zoom) ----------
  function updateTransform(){
    const {panX, panY, scale} = state.view;
    el.world.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
    el.grid.style.backgroundPosition = `${-panX}px ${-panY}px`;
  }

  function centerView(){
    state.view.panX = window.innerWidth/2;
    state.view.panY = window.innerHeight/2;
    state.view.scale = 1;
    updateTransform();
  }

  function zoomAt(screenX, screenY, newScale){
    const s = clamp(newScale, 0.1, 6);

    const before = screenToWorld(screenX, screenY);
    state.view.scale = s;
    const after = screenToWorld(screenX, screenY);

    state.view.panX += (after.x - before.x) * s;
    state.view.panY += (after.y - before.y) * s;

    updateTransform();
    markDirty({lines:true, meas:true});
  }

  // ---------- Objects ----------
  function addObject(type, opts = {}){
    const id = uid();
    const wPos = screenToWorld(window.innerWidth/2, window.innerHeight/2);

    const base = {
      id,
      type,
      x: opts.x ?? wPos.x,
      y: opts.y ?? wPos.y,
      rot: opts.rot ?? 0,
      layer: opts.layer ?? "1",
      label: sanitizeLabel(opts.label ?? (type === "camera" ? "CAM" : type === "actor" ? "Actor" : "Prop")),
      color: opts.color ?? (type === "actor" ? "#f43f5e" : ""),
      w: opts.w ?? (type === "prop" ? 40 : 0),
      h: opts.h ?? (type === "prop" ? 25 : 0),
      icon: opts.icon ?? (type === "prop" ? "fa-cube" : ""),
      // camera lens:
      sensor: opts.sensor ?? "FF",
      focal: opts.focal ?? 35,
      fovOverride: opts.fovOverride ?? 60, // optional manual override slider
      useFovOverride: !!opts.useFovOverride, // if true -> uses override instead of lens hfov/vfov
      // links
      targetId: opts.targetId ?? null,
      nextPathId: opts.nextPathId ?? null,
      isGhost: !!opts.isGhost,
    };

    state.objects.push(base);
    selectObject(id);
    markDirty({render:true, lines:true, meas:true});
    saveState();
    return id;
  }

  function cloneAsGhost(sourceId){
    const src = getObject(sourceId);
    if(!src) return null;

    const ghostId = addObject(src.type, {
      x: src.x + 60,
      y: src.y,
      rot: src.rot,
      layer: src.layer,
      label: "Step",
      color: src.color,
      w: src.w,
      h: src.h,
      icon: src.icon,
      sensor: src.sensor,
      focal: src.focal,
      fovOverride: src.fovOverride,
      useFovOverride: src.useFovOverride,
      isGhost: true
    });

    src.nextPathId = ghostId;

    markDirty({render:true, lines:true, meas:true});
    saveState();
    return ghostId;
  }

  // ---------- DOM Render ----------
  function ensureElementForObject(o){
    let node = document.getElementById(o.id);
    if(node) return node;

    node = document.createElement("div");
    node.id = o.id;
    node.className = "scene-object group";
    node.tabIndex = -1;

    node.addEventListener("pointerdown", (e) => onObjectPointerDown(e, o.id));
    el.world.appendChild(node);
    return node;
  }

  function buildVisualHTML(o){
    if(o.type === "camera"){
      const {hfov} = computeFovDegrees(o.sensor, o.focal);
      const spread = clamp(hfov, 20, 120) * 2; // aesthetic mapping
      return `
        <div class="fov-cone" style="border-left-width:${spread}px; border-right-width:${spread}px;"></div>
        <div class="cam-body object-visual flex items-center justify-center">
          <div class="w-1.5 h-1.5 bg-black/50 rounded-full"></div>
        </div>
      `;
    }
    if(o.type === "actor"){
      return `
        <div class="w-10 h-10 rounded-full object-visual shadow-lg relative border-2 border-white/20"
             style="background-color:${o.color || "#f43f5e"}">
          <div class="absolute top-0 left-1/2 -translate-x-1/2 w-2 h-2 bg-white rounded-full -mt-1"></div>
        </div>
      `;
    }
    const w = Math.max(20, o.w || 40);
    const h = Math.max(20, o.h || 25);
    const bg = o.color ? `background-color:${o.color}; border-color:${o.color};` : "";
    return `
      <div class="prop-visual object-visual bg-white/5 rounded-xl text-white/80"
           style="width:${w}px; height:${h}px; ${bg}">
        <i class="fa-solid ${o.icon || "fa-cube"} text-lg"></i>
      </div>
    `;
  }

  function renderObjectsDOM(){
    const ids = new Set(state.objects.map(o => o.id));
    [...el.world.querySelectorAll(".scene-object")].forEach(n => {
      if(!ids.has(n.id)) n.remove();
    });

    state.objects.forEach(o => {
      const node = ensureElementForObject(o);

      node.classList.toggle("ghost", !!o.isGhost);
      node.classList.toggle("hidden-layer", !state.layerVisibility[o.layer]);
      node.classList.toggle("selected", state.selectedId === o.id);

      node.style.left = `${o.x}px`;
      node.style.top = `${o.y}px`;
      node.style.transform = `translate(-50%, -50%) rotate(${o.rot}deg)`;

      const currentType = node.dataset.type;
      if(currentType !== o.type || !node.querySelector(".object-visual")){
        node.dataset.type = o.type;
        node.innerHTML = `
          ${buildVisualHTML(o)}
          <div class="text-[8px] font-bold mt-3 opacity-0 group-hover:opacity-100 bg-black/80 text-white px-2 py-1 rounded-md backdrop-blur-md label-tag whitespace-nowrap transition-opacity border border-white/10 pointer-events-none">${o.label}</div>
          <div class="control-handle rotate-handle"><i class="fa-solid fa-rotate"></i></div>
          <div class="control-handle resize-handle"></div>
          <div class="layer-badge">${o.layer}</div>
        `;
        node.querySelector(".rotate-handle").addEventListener("pointerdown", (e) => onRotatePointerDown(e, o.id));
        node.querySelector(".resize-handle").addEventListener("pointerdown", (e) => onResizePointerDown(e, o.id));
      } else {
        const label = node.querySelector(".label-tag");
        if(label) label.textContent = o.label;

        const badge = node.querySelector(".layer-badge");
        if(badge) badge.textContent = o.layer;

        if(o.type === "camera"){
          const {hfov} = computeFovDegrees(o.sensor, o.focal);
          const spread = clamp(hfov, 20, 120) * 2;
          const cone = node.querySelector(".fov-cone");
          if(cone){
            cone.style.borderLeftWidth = `${spread}px`;
            cone.style.borderRightWidth = `${spread}px`;
          }
        }
        if(o.type === "prop"){
          const vis = node.querySelector(".object-visual");
          if(vis){
            vis.style.width = `${Math.max(20, o.w || 40)}px`;
            vis.style.height = `${Math.max(20, o.h || 25)}px`;
            if(o.color){
              vis.style.backgroundColor = o.color;
              vis.style.borderColor = o.color;
            } else {
              vis.style.backgroundColor = "";
              vis.style.borderColor = "";
            }
            const icon = vis.querySelector("i");
            if(icon) icon.className = `fa-solid ${o.icon || "fa-cube"} text-lg`;
          }
        }
        if(o.type === "actor"){
          const vis = node.querySelector(".object-visual");
          if(vis) vis.style.backgroundColor = o.color || "#f43f5e";
        }
      }

      const label = node.querySelector(".label-tag");
      if(label) label.style.transform = `rotate(${-o.rot}deg)`;
    });

    const hasSel = !!state.selectedId;
    el.editBar.classList.toggle("hidden", !hasSel);
    el.editBar.classList.toggle("flex", hasSel);

    applyLayerVisibilityIcons();
  }

  // ---------- Connections ----------
  function drawConnections(){
    el.svg.innerHTML = "";
    const off = 5000;

    state.objects.forEach(o => {
      if(!o.nextPathId) return;
      const to = getObject(o.nextPathId);
      if(!to) return;

      const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
      line.setAttribute("stroke", "#ffa300");
      line.setAttribute("stroke-dasharray", "4,4");
      line.setAttribute("opacity", "0.6");
      line.setAttribute("stroke-width", "1.5");
      line.setAttribute("x1", (o.x + off).toString());
      line.setAttribute("y1", (o.y + off).toString());
      line.setAttribute("x2", (to.x + off).toString());
      line.setAttribute("y2", (to.y + off).toString());
      el.svg.appendChild(line);
    });
  }

  // ---------- Measurements ----------
  function drawMeasurements(){
    el.meas.innerHTML = "";
    if(!state.measurementsEnabled || !state.selectedId) return;

    const off = 5000;
    const s = getObject(state.selectedId);
    if(!s) return;

    state.objects.forEach(o => {
      if(o.id === s.id) return;
      if(!state.layerVisibility[o.layer]) return;

      const dx = o.x - s.x;
      const dy = o.y - s.y;
      const dist = Math.hypot(dx, dy);
      const angle = Math.atan2(dy, dx) * (180/Math.PI);

      const line = document.createElementNS("http://www.w3.org/2000/svg","line");
      line.setAttribute("class","measurement-line");
      line.setAttribute("x1", (s.x+off).toString());
      line.setAttribute("y1", (s.y+off).toString());
      line.setAttribute("x2", (o.x+off).toString());
      line.setAttribute("y2", (o.y+off).toString());
      el.meas.appendChild(line);

      const text = document.createElementNS("http://www.w3.org/2000/svg","text");
      text.setAttribute("class","measurement-text");
      text.setAttribute("x", ((s.x+o.x)/2 + off).toString());
      text.setAttribute("y", ((s.y+o.y)/2 + off - 6).toString());
      text.setAttribute("text-anchor","middle");
      text.textContent = `${Math.round(dist)}px / ${Math.round(angle)}°`;
      el.meas.appendChild(text);
    });
  }

  // ---------- Selection + Inspector ----------
  function selectObject(id){
    state.selectedId = id;
    const o = getObject(id);
    if(!o) return;

    el.inspName.value = o.label;
    el.inspLayer.value = o.layer;

    if(o.type === "camera"){
      el.camControls.classList.remove("hidden");

      el.sensorSelect.value = o.sensor || "FF";
      el.focalInput.value = String(o.focal ?? 35);

      const {hfov, vfov} = computeFovDegrees(o.sensor, o.focal);
      el.hfovReadout.textContent = `${hfov.toFixed(1)}°`;
      el.vfovReadout.textContent = `${vfov.toFixed(1)}°`;

      el.fovSlider.value = String(o.fovOverride ?? 60);
      el.fovValue.textContent = String(o.fovOverride ?? 60);

      if(o.targetId){
        el.targetStatus.classList.remove("hidden");
        const t = getObject(o.targetId);
        el.targetName.textContent = t ? t.label : "Unknown";
      } else {
        el.targetStatus.classList.add("hidden");
      }
    } else {
      el.camControls.classList.add("hidden");
    }

    markDirty({render:true, meas:true});
  }

  function deselect(){
    state.selectedId = null;
    el.targetStatus.classList.add("hidden");
    closeInspector();
    markDirty({render:true, meas:true});
  }

  function openInspector(){ el.inspector.style.transform = "translateY(-50%) translateX(0)"; }
  function closeInspector(){ el.inspector.style.transform = "translateY(-50%) translateX(150%)"; }

  // ---------- Tracking ----------
  function updateTrackingRotationsIfNeeded(){
    let changed = false;
    state.objects.forEach(o => {
      if(o.type !== "camera" || !o.targetId) return;
      const t = getObject(o.targetId);
      if(!t) return;

      const dx = t.x - o.x;
      const dy = t.y - o.y;
      const ang = Math.atan2(dy, dx) * (180/Math.PI) + 90;
      if(Math.abs(ang - o.rot) > 0.001){
        o.rot = ang;
        changed = true;
      }
    });
    if(changed) markDirty({render:true, lines:true, meas:true});
  }

  // ---------- Undo/Redo ----------
  function snapshotState(){
    return {
      sceneName: state.sceneName,
      view: { ...state.view },
      objects: state.objects.map(o => ({...o})),
      layerVisibility: { ...state.layerVisibility },
      measurementsEnabled: state.measurementsEnabled,
      snapEnabled: state.snapEnabled,
      pxPerMeter: state.pxPerMeter,
      storyboard: { ...state.storyboard },
    };
  }

  function restoreSnapshot(snap){
    state.sceneName = snap.sceneName ?? "Untitled";
    state.view = { ...snap.view };
    state.objects = (snap.objects ?? []).map(o => ({...o}));
    state.layerVisibility = { ...snap.layerVisibility };
    state.measurementsEnabled = !!snap.measurementsEnabled;
    state.snapEnabled = !!snap.snapEnabled;
    state.pxPerMeter = Number(snap.pxPerMeter ?? 100);
    state.storyboard = { ...(snap.storyboard ?? {aspect:2.39, overlays:true}) };
    state.selectedId = null;
    state.targetMode = false;

    el.sceneNameDisplay.textContent = state.sceneName;

    updateTransform();
    el.meas.innerHTML = "";
    markDirty({render:true, lines:true, meas:true});
    updateUndoRedoButtons();
    updateTopButtonsState();
  }

  function saveState(){
    const snap = snapshotState();

    if(state.historyIndex < state.history.length - 1){
      state.history = state.history.slice(0, state.historyIndex + 1);
    }
    state.history.push(JSON.stringify(snap));
    if(state.history.length > MAX_HISTORY){
      state.history.shift();
    } else {
      state.historyIndex++;
    }
    updateUndoRedoButtons();
  }

  function undo(){
    if(state.historyIndex <= 0) return;
    state.historyIndex--;
    restoreSnapshot(JSON.parse(state.history[state.historyIndex]));
  }

  function redo(){
    if(state.historyIndex >= state.history.length - 1) return;
    state.historyIndex++;
    restoreSnapshot(JSON.parse(state.history[state.historyIndex]));
  }

  function updateUndoRedoButtons(){
    el.undoBtn.disabled = !(state.historyIndex > 0);
    el.redoBtn.disabled = !(state.historyIndex < state.history.length - 1);
    el.undoBtn.classList.toggle("opacity-40", el.undoBtn.disabled);
    el.redoBtn.classList.toggle("opacity-40", el.redoBtn.disabled);
  }

  function updateTopButtonsState(){
    el.measureBtn.classList.toggle("text-brand", state.measurementsEnabled);
    el.snapBtn.classList.toggle("text-brand", state.snapEnabled);
  }

  // ---------- Scene Manager ----------
  function saveScene(){
    const name = normalizeKeyName(el.sceneNameInput.value || `Scene ${Date.now()}`);
    state.sceneName = name;
    el.sceneNameDisplay.textContent = name;
    el.sceneNameInput.value = name;

    localStorage.setItem(storageKey(name), JSON.stringify(snapshotState()));
    loadSceneList();
  }

  function loadSceneList(){
    el.savedList.innerHTML = "";
    const keys = [];
    for(let i=0;i<localStorage.length;i++){
      const k = localStorage.key(i);
      if(k && k.startsWith(`${VERSION}::scene::`)) keys.push(k);
    }
    keys.sort((a,b) => a.localeCompare(b));

    keys.forEach(k => {
      const name = k.split("::scene::")[1] || "Scene";
      const row = document.createElement("div");
      row.className = "flex justify-between items-center bg-white/5 p-3 rounded-xl text-[10px]";
      row.innerHTML = `
        <span class="font-bold text-white/70">${name}</span>
        <div class="flex gap-3">
          <button class="text-brand hover:text-white" data-open="${name}">OPEN</button>
          <button class="text-red-400 hover:text-white" data-del="${name}" aria-label="Elimina scena" title="Elimina">
            <i class="fa-solid fa-trash"></i>
          </button>
        </div>
      `;
      row.querySelector("[data-open]").addEventListener("click", () => loadScene(name));
      row.querySelector("[data-del]").addEventListener("click", () => deleteScene(name));
      el.savedList.appendChild(row);
    });
  }

  function loadScene(name){
    const raw = localStorage.getItem(storageKey(name));
    if(!raw) return;
    restoreSnapshot(JSON.parse(raw));

    state.history = [];
    state.historyIndex = -1;
    saveState();

    closeSceneMenu();
  }

  function deleteScene(name){
    localStorage.removeItem(storageKey(name));
    loadSceneList();
  }

  function createNewScene(){
    state.sceneName = "Untitled";
    el.sceneNameDisplay.textContent = "Untitled";
    el.sceneNameInput.value = "";

    state.objects = [];
    state.selectedId = null;
    state.targetMode = false;
    state.measurementsEnabled = false;
    state.snapEnabled = false;
    state.layerVisibility = {1:true,2:true,3:true};

    el.svg.innerHTML = "";
    el.meas.innerHTML = "";

    state.history = [];
    state.historyIndex = -1;

    centerView();
    updateTopButtonsState();
    markDirty({render:true, lines:true, meas:true});
    saveState();
    closeSceneMenu();
  }

  function openSceneMenu(){
    el.sceneMenu.classList.remove("hidden");
    el.sceneMenu.classList.add("flex");
    loadSceneList();
  }

  function closeSceneMenu(){
    el.sceneMenu.classList.add("hidden");
    el.sceneMenu.classList.remove("flex");
  }

  // ---------- Layers ----------
  function toggleLayers(){
    const p = el.layersPanel;
    const isHidden = p.style.transform.includes("-150%") || p.classList.contains("-translate-x-[150%]");
    p.style.transform = isHidden ? "translateY(-50%) translateX(0)" : "translateY(-50%) translateX(-150%)";
  }

  function toggleLayerVisibility(layer){
    state.layerVisibility[layer] = !state.layerVisibility[layer];
    applyLayerVisibilityIcons();
    markDirty({render:true, meas:true});
    saveState();
  }

  function applyLayerVisibilityIcons(){
    [1,2,3].forEach(l => {
      const eye = document.getElementById(`layer-eye-${l}`);
      if(!eye) return;
      eye.className = state.layerVisibility[l] ? "fa-solid fa-eye text-xs opacity-60" : "fa-solid fa-eye-slash text-xs opacity-60";
    });
  }

  function updateLayer(layer){
    if(!state.selectedId) return;
    const o = getObject(state.selectedId);
    if(!o) return;
    o.layer = String(layer);
    markDirty({render:true, meas:true});
    saveState();
  }

  // ---------- Measurements / Snap ----------
  function toggleMeasurements(){
    state.measurementsEnabled = !state.measurementsEnabled;
    if(!state.measurementsEnabled) el.meas.innerHTML = "";
    updateTopButtonsState();
    markDirty({meas:true});
    saveState();
  }

  function toggleSnap(){
    state.snapEnabled = !state.snapEnabled;
    updateTopButtonsState();
    saveState();
  }

  // ---------- Props ----------
  function filterProps(cat){
    el.propGrid.innerHTML = "";
    (propDB[cat] || []).forEach(p => {
      const b = document.createElement("button");
      b.className = "aspect-square bg-white/5 border border-white/10 rounded-2xl flex flex-col items-center justify-center hover:bg-white/10 transition";
      b.innerHTML = `<i class="fa-solid ${p.i} text-xl mb-2 text-white/50"></i><span class="text-[8px] uppercase font-bold text-brand">${p.n}</span>`;
      b.addEventListener("click", () => {
        addObject("prop", { label: p.n, icon: p.i, w: p.w, h: p.h });
        closePropPicker();
      });
      el.propGrid.appendChild(b);
    });
  }

  function openPropPicker(){
    el.propPicker.classList.remove("hidden");
    el.propPicker.classList.add("flex");
  }
  function closePropPicker(){
    el.propPicker.classList.add("hidden");
    el.propPicker.classList.remove("flex");
  }

  // ---------- Pointer Navigation ----------
  function onViewportPointerDown(e){
    if(e.target.closest(".scene-object") || e.target.closest(".control-handle")) return;

    el.viewport.setPointerCapture(e.pointerId);
    state.pointers.set(e.pointerId, { clientX: e.clientX, clientY: e.clientY });

    deselect();

    if(state.pointers.size === 2){
      const pts = [...state.pointers.values()];
      const dx = pts[1].clientX - pts[0].clientX;
      const dy = pts[1].clientY - pts[0].clientY;
      state.pinch.initialDist = Math.hypot(dx, dy);
      state.pinch.initialScale = state.view.scale;
      state.pinch.mid = { x: (pts[0].clientX + pts[1].clientX)/2, y: (pts[0].clientY + pts[1].clientY)/2 };
    }
  }

  function onViewportPointerMove(e){
    if(!state.pointers.has(e.pointerId)) return;

    const prev = state.pointers.get(e.pointerId);
    state.pointers.set(e.pointerId, { clientX: e.clientX, clientY: e.clientY });

    const pts = [...state.pointers.values()];
    if(pts.length === 2){
      const dx = pts[1].clientX - pts[0].clientX;
      const dy = pts[1].clientY - pts[0].clientY;
      const dist = Math.hypot(dx, dy);
      if(state.pinch.initialDist > 0){
        const factor = dist / state.pinch.initialDist;
        zoomAt(state.pinch.mid.x, state.pinch.mid.y, state.pinch.initialScale * factor);
      }
    } else if(pts.length === 1){
      const dx = e.clientX - prev.clientX;
      const dy = e.clientY - prev.clientY;
      state.view.panX += dx;
      state.view.panY += dy;
      updateTransform();
      markDirty({lines:true, meas:true});
    }
  }

  function onViewportPointerUp(e){
    if(state.pointers.has(e.pointerId)) state.pointers.delete(e.pointerId);
    try{ el.viewport.releasePointerCapture(e.pointerId); } catch {}
  }

  function onViewportPointerCancel(e){
    if(state.pointers.has(e.pointerId)) state.pointers.delete(e.pointerId);
    try{ el.viewport.releasePointerCapture(e.pointerId); } catch {}
  }

  // ---------- Object interactions ----------
  function onObjectPointerDown(e, id){
    if(e.target.closest(".control-handle")) return;
    e.stopPropagation();

    if(state.targetMode){
      const clicked = getObject(id);
      if(clicked && clicked.type === "actor" && state.selectedId){
        const cam = getObject(state.selectedId);
        if(cam && cam.type === "camera"){
          cam.targetId = clicked.id;
          state.targetMode = false;
          document.body.style.cursor = "default";
          selectObject(cam.id);
          saveState();
          return;
        }
      }
    }

    selectObject(id);

    const o = getObject(id);
    if(!o) return;

    const start = { x: o.x, y: o.y, px: e.clientX, py: e.clientY };

    const node = document.getElementById(id);
    node.setPointerCapture(e.pointerId);

    function move(ev){
      const dx = (ev.clientX - start.px) / state.view.scale;
      const dy = (ev.clientY - start.py) / state.view.scale;

      let nx = start.x + dx;
      let ny = start.y + dy;

      if(state.snapEnabled){
        nx = Math.round(nx / GRID_SNAP) * GRID_SNAP;
        ny = Math.round(ny / GRID_SNAP) * GRID_SNAP;
      }

      o.x = nx; o.y = ny;
      markDirty({render:true, lines:true, meas:true});
    }

    function up(){
      node.removeEventListener("pointermove", move);
      node.removeEventListener("pointerup", up);
      node.removeEventListener("pointercancel", up);
      try{ node.releasePointerCapture(e.pointerId); } catch {}
      saveState();
    }

    node.addEventListener("pointermove", move);
    node.addEventListener("pointerup", up, { once:true });
    node.addEventListener("pointercancel", up, { once:true });
  }

  function onRotatePointerDown(e, id){
    e.stopPropagation();
    selectObject(id);

    const o = getObject(id);
    const node = document.getElementById(id);
    if(!o || !node) return;

    node.setPointerCapture(e.pointerId);

    function move(ev){
      const rect = node.getBoundingClientRect();
      const cx = rect.left + rect.width/2;
      const cy = rect.top + rect.height/2;
      const ang = Math.atan2(ev.clientY - cy, ev.clientX - cx) * (180/Math.PI) + 90;
      o.rot = ang;
      markDirty({render:true, lines:true, meas:true});
    }

    function up(){
      node.removeEventListener("pointermove", move);
      node.removeEventListener("pointerup", up);
      node.removeEventListener("pointercancel", up);
      try{ node.releasePointerCapture(e.pointerId); } catch {}
      saveState();
    }

    node.addEventListener("pointermove", move);
    node.addEventListener("pointerup", up, { once:true });
    node.addEventListener("pointercancel", up, { once:true });
  }

  function onResizePointerDown(e, id){
    e.stopPropagation();
    selectObject(id);

    const o = getObject(id);
    const node = document.getElementById(id);
    if(!o || !node) return;
    if(o.type !== "prop") return;

    node.setPointerCapture(e.pointerId);

    const start = { w: o.w || 40, h: o.h || 25, px: e.clientX, py: e.clientY };

    function move(ev){
      const dx = (ev.clientX - start.px) / state.view.scale;
      const dy = (ev.clientY - start.py) / state.view.scale;

      o.w = Math.max(20, start.w + dx);
      o.h = Math.max(20, start.h + dy);

      if(state.snapEnabled){
        o.w = Math.round(o.w / GRID_SNAP) * GRID_SNAP;
        o.h = Math.round(o.h / GRID_SNAP) * GRID_SNAP;
      }

      markDirty({render:true, lines:true, meas:true});
    }

    function up(){
      node.removeEventListener("pointermove", move);
      node.removeEventListener("pointerup", up);
      node.removeEventListener("pointercancel", up);
      try{ node.releasePointerCapture(e.pointerId); } catch {}
      saveState();
    }

    node.addEventListener("pointermove", move);
    node.addEventListener("pointerup", up, { once:true });
    node.addEventListener("pointercancel", up, { once:true });
  }

  // ---------- Inspector bindings ----------
  function updateLabel(val){
    if(!state.selectedId) return;
    const o = getObject(state.selectedId);
    if(!o) return;
    o.label = sanitizeLabel(val) || (o.type === "camera" ? "CAM" : o.type);
    markDirty({render:true});
  }

  function setColor(hex){
    if(!state.selectedId) return;
    const o = getObject(state.selectedId);
    if(!o) return;
    o.color = hex;
    markDirty({render:true});
  }

  function updateLensFromInspector(){
    if(!state.selectedId) return;
    const o = getObject(state.selectedId);
    if(!o || o.type !== "camera") return;

    o.sensor = el.sensorSelect.value || "FF";
    o.focal = clamp(Number(el.focalInput.value || 35), 8, 300);

    const {hfov, vfov} = computeFovDegrees(o.sensor, o.focal);
    el.hfovReadout.textContent = `${hfov.toFixed(1)}°`;
    el.vfovReadout.textContent = `${vfov.toFixed(1)}°`;

    markDirty({render:true});
    saveState();
  }

  function updateFovOverride(value){
    if(!state.selectedId) return;
    const o = getObject(state.selectedId);
    if(!o || o.type !== "camera") return;
    o.fovOverride = clamp(Number(value || 60), 20, 120);
    el.fovValue.textContent = String(o.fovOverride);
    // (facoltativo) se vuoi usare l'override davvero, attiva qui:
    // o.useFovOverride = true;
    markDirty({render:true});
    saveState();
  }

  function activateTargetMode(){
    if(!state.selectedId) return;
    const o = getObject(state.selectedId);
    if(!o || o.type !== "camera") return;
    state.targetMode = true;
    document.body.style.cursor = "crosshair";
    closeInspector();
  }

  // ---------- Delete + chain repair ----------
  function deleteSelected(){
    if(!state.selectedId) return;
    const id = state.selectedId;

    const parent = state.objects.find(o => o.nextPathId === id) || null;
    const current = getObject(id);

    if(parent && current){
      parent.nextPathId = current.nextPathId ? current.nextPathId : null;
    }

    state.objects.forEach(o => {
      if(o.targetId === id) o.targetId = null;
      if(o.nextPathId === id) o.nextPathId = null;
    });

    state.objects = state.objects.filter(o => o.id !== id);
    deselect();

    markDirty({render:true, lines:true, meas:true});
    saveState();
  }

  function addGhostPath(){
    if(!state.selectedId) return;
    cloneAsGhost(state.selectedId);
  }

  // ---------- Animation (simple) ----------
  function buildTimelines(){
    const roots = state.objects.filter(o => !o.isGhost && !!o.nextPathId);
    const timelines = [];

    roots.forEach(root => {
      const path = [];
      let cur = root;
      let guard = 0;
      while(cur.nextPathId && guard++ < 200){
        const nxt = getObject(cur.nextPathId);
        if(!nxt) break;
        path.push({ x: nxt.x, y: nxt.y });
        cur = nxt;
      }
      timelines.push({ id: root.id, path });
    });

    return timelines;
  }

  function formatMs(ms){
    const m = Math.floor(ms/60000);
    const s = Math.floor((ms%60000)/1000);
    return `${m}:${String(s).padStart(2,"0")}`;
  }

  function playScene(){
    if(state.isAnimating) return;

    const timelines = buildTimelines();
    if(timelines.length === 0) return;

    state.animationTimelines = timelines;
    state.animationInitialPositions.clear();
    timelines.forEach(tl => {
      const o = getObject(tl.id);
      if(o) state.animationInitialPositions.set(tl.id, { x: o.x, y: o.y });
    });

    const stepDuration = 1400;
    const totalSteps = Math.max(...timelines.map(t => t.path.length));
    const totalDuration = Math.max(1, totalSteps * stepDuration);

    state.animationDuration = totalDuration;
    state.animationStartTime = performance.now();
    state.isAnimating = true;

    el.timeline.classList.remove("hidden");
    el.timeline.classList.add("flex");
    el.timelineDuration.textContent = formatMs(totalDuration);

    el.playBtn.innerHTML = `<i class="fa-solid fa-circle-notch fa-spin"></i> RUNNING`;
    requestAnimationFrame(animationLoop);
  }

  function animationLoop(now){
    const elapsed = now - state.animationStartTime;
    const progress = clamp(elapsed / state.animationDuration, 0, 1);

    el.timelineScrubber.style.background = `linear-gradient(to right, var(--brand) ${progress*100}%, transparent ${progress*100}%)`;
    el.timelinePlayhead.style.left = `calc(${progress*100}% - 8px)`;

    const stepDuration = 1400;

    state.animationTimelines.forEach(tl => {
      const o = getObject(tl.id);
      if(!o || tl.path.length === 0) return;

      const totalSteps = tl.path.length;
      const total = totalSteps * stepDuration;
      const local = clamp(elapsed / total, 0, 1) * totalSteps;

      const idx = Math.min(totalSteps - 1, Math.floor(local));
      const segT = local - idx;
      const ease = segT < 0.5 ? 2*segT*segT : -1 + (4 - 2*segT)*segT;

      const startPos = (idx === 0) ? state.animationInitialPositions.get(tl.id) : tl.path[idx-1];
      const endPos = tl.path[idx];

      if(startPos && endPos){
        o.x = startPos.x + (endPos.x - startPos.x) * ease;
        o.y = startPos.y + (endPos.y - startPos.y) * ease;
      }
    });

    markDirty({render:true, lines:true, meas:true});

    if(progress < 1){
      requestAnimationFrame(animationLoop);
    } else {
      state.animationTimelines.forEach(tl => {
        const o = getObject(tl.id);
        const init = state.animationInitialPositions.get(tl.id);
        if(o && init){ o.x = init.x; o.y = init.y; }
      });

      state.isAnimating = false;
      el.playBtn.innerHTML = `<i class="fa-solid fa-play"></i> ACTION`;

      el.timelineScrubber.style.background = `linear-gradient(to right, var(--brand) 0%, transparent 0%)`;
      el.timelinePlayhead.style.left = "0";
      markDirty({render:true, lines:true, meas:true});
    }
  }

  function closeTimeline(){
    el.timeline.classList.add("hidden");
    el.timeline.classList.remove("flex");
  }

  // ---------- Snapshot ----------
  async function takeSnapshot(){
    const prev = el.world.style.transform;
    el.world.style.transform = "none";
    const bg = getComputedStyle(document.body).getPropertyValue("--bg-color").trim() || "#0d0d0d";
    const canvas = await html2canvas(el.world, { backgroundColor: bg });
    const a = document.createElement("a");
    a.download = `${state.sceneName || "Scene"}_Plan.png`;
    a.href = canvas.toDataURL("image/png");
    a.click();
    el.world.style.transform = prev;
  }

  // ---------- POV Renderer (DoP-style) ----------
  function getActiveRect(W, H, aspect){
    const canvasAspect = W / H; // 16/9
    if(aspect <= canvasAspect + 1e-6){
      // aspect <= 16/9 -> no bars (or side bars, but we won't use those here)
      return { x: 0, y: 0, w: W, h: H };
    }
    // letterbox top/bottom
    const h = W / aspect;
    const y = (H - h) / 2;
    return { x: 0, y, w: W, h };
  }

  function estimateShotSize(frameH_m, subjectH_m){
    if(frameH_m <= 0) return "–";
    const r = subjectH_m / frameH_m; // how much of frame height subject occupies
    if(r < 0.08) return "Extreme Wide";
    if(r < 0.15) return "Wide";
    if(r < 0.28) return "Medium";
    if(r < 0.45) return "Medium Close";
    if(r < 0.65) return "Close-Up";
    return "Extreme Close-Up";
  }

  function cameraPOVRenderToCanvas(camObj, canvas){
    const ctx = canvas.getContext("2d");
    const W = canvas.width;
    const H = canvas.height;

    ctx.clearRect(0,0,W,H);

    // background
    const sky = ctx.createLinearGradient(0,0,0,H);
    sky.addColorStop(0, "rgba(255,255,255,0.07)");
    sky.addColorStop(0.35, "rgba(255,255,255,0.03)");
    sky.addColorStop(1, "rgba(0,0,0,0.35)");
    ctx.fillStyle = sky;
    ctx.fillRect(0,0,W,H);

    const active = getActiveRect(W, H, state.storyboard.aspect);

    // letterbox bars
    ctx.fillStyle = "rgba(0,0,0,0.92)";
    if(active.y > 0){
      ctx.fillRect(0, 0, W, active.y);
      ctx.fillRect(0, active.y + active.h, W, H - (active.y + active.h));
    }

    // vignette
    const v = ctx.createRadialGradient(W/2, H/2, Math.min(W,H)*0.15, W/2, H/2, Math.min(W,H)*0.85);
    v.addColorStop(0, "rgba(0,0,0,0)");
    v.addColorStop(1, "rgba(0,0,0,0.55)");
    ctx.fillStyle = v;
    ctx.fillRect(0,0,W,H);

    // FOV from lens
    const {hfov, vfov} = computeFovDegrees(camObj.sensor, camObj.focal);
    const halfHFov = (hfov * Math.PI/180) / 2;

    const {fx, fy} = forwardVector(camObj.rot ?? 0);

    // visible objects in camera space
    const objects = state.objects
      .filter(o => o.id !== camObj.id)
      .filter(o => state.layerVisibility[o.layer])
      .filter(o => !o.isGhost);

    const visible = [];
    let maxForwardPx = 600;

    objects.forEach(o => {
      const dx = o.x - camObj.x;
      const dy = o.y - camObj.y;

      const dot = fx*dx + fy*dy;        // forward (px)
      const cross = fx*dy - fy*dx;      // sideways (px)
      const angle = Math.atan2(cross, dot);

      if(dot <= 10) return;
      if(Math.abs(angle) > halfHFov) return;

      maxForwardPx = Math.max(maxForwardPx, dot);
      visible.push({ o, dotPx: dot, angle });
    });

    // "horizon" inside active rect
    const horizonY = active.y + active.h * 0.38;

    // overlays (safe/thirds)
    if(state.storyboard.overlays){
      // thirds
      ctx.strokeStyle = "rgba(255,255,255,0.05)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(active.x + active.w/3, active.y); ctx.lineTo(active.x + active.w/3, active.y + active.h);
      ctx.moveTo(active.x + 2*active.w/3, active.y); ctx.lineTo(active.x + 2*active.w/3, active.y + active.h);
      ctx.moveTo(active.x, active.y + active.h/3); ctx.lineTo(active.x + active.w, active.y + active.h/3);
      ctx.moveTo(active.x, active.y + 2*active.h/3); ctx.lineTo(active.x + active.w, active.y + 2*active.h/3);
      ctx.stroke();

      // safe action (10%)
      ctx.strokeStyle = "rgba(255,255,255,0.08)";
      ctx.setLineDash([6,6]);
      ctx.strokeRect(active.x + active.w*0.10, active.y + active.h*0.10, active.w*0.80, active.h*0.80);

      // safe title (20%)
      ctx.strokeStyle = "rgba(255,255,255,0.06)";
      ctx.strokeRect(active.x + active.w*0.20, active.y + active.h*0.20, active.w*0.60, active.h*0.60);
      ctx.setLineDash([]);
    }

    // painter sort far->near
    visible.sort((a,b) => b.dotPx - a.dotPx);

    // projection helpers (into active rect)
    function projX(angle){
      return active.x + (angle / halfHFov) * (active.w/2) + (active.w/2);
    }
    function projY(forwardPx){
      const t = clamp(forwardPx / maxForwardPx, 0, 1);
      return horizonY + (active.h*0.58) * Math.pow(1 - t, 0.72);
    }
    function size(forwardPx){
      const focal = 520;
      const s = focal / (forwardPx + focal);
      return clamp(s, 0.10, 0.95);
    }

    // draw
    const baseActor = 46;
    visible.forEach(v => {
      const o = v.o;
      const x = projX(v.angle);
      const y = projY(v.dotPx);
      const s = size(v.dotPx);

      const col = (o.color && o.color.trim()) ? o.color : "#ffffff";

      ctx.save();
      ctx.translate(x, y);

      // ground shadow
      ctx.fillStyle = "rgba(0,0,0,0.25)";
      ctx.beginPath();
      ctx.ellipse(0, 10*s, 26*s, 10*s, 0, 0, Math.PI*2);
      ctx.fill();

      if(o.type === "actor"){
        const r = baseActor * s * 0.55;
        ctx.fillStyle = col;
        ctx.beginPath();
        ctx.arc(0, 0, r, 0, Math.PI*2);
        ctx.fill();

        ctx.fillStyle = "rgba(255,255,255,0.25)";
        ctx.beginPath();
        ctx.arc(-r*0.25, -r*0.25, r*0.18, 0, Math.PI*2);
        ctx.fill();
      } else if(o.type === "prop"){
        const w = (Math.max(20, o.w || 40) * s) * 1.1;
        const h = (Math.max(20, o.h || 25) * s) * 1.1;
        ctx.fillStyle = "rgba(255,255,255,0.10)";
        ctx.strokeStyle = col || "rgba(255,255,255,0.22)";
        ctx.lineWidth = 2;
        roundRect(ctx, -w/2, -h/2, w, h, 10*s);
        ctx.fill();
        ctx.stroke();
      } else {
        ctx.strokeStyle = col;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(0, 0, 18*s, 0, Math.PI*2);
        ctx.stroke();
      }

      // label (subtle)
      ctx.font = `${Math.max(11, 14*s)}px ui-sans-serif, system-ui, -apple-system`;
      ctx.textAlign = "center";
      ctx.fillStyle = "rgba(255,255,255,0.80)";
      ctx.fillText(o.label || o.type, 0, 32*s);

      ctx.restore();
    });

    // metadata overlay (DoP-friendly)
    if(state.storyboard.overlays){
      const topH = 28;
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.fillRect(0, 0, W, topH);

      // compute distance/shot size if tracking target
      let distM = null, shot = null;
      if(camObj.targetId){
        const t = getObject(camObj.targetId);
        if(t){
          const distPx = Math.hypot(t.x - camObj.x, t.y - camObj.y);
          distM = distPx / state.pxPerMeter;

          // frame height in meters at distance (use VFOV)
          const vfovRad = (vfov * Math.PI/180);
          const frameH_m = 2 * distM * Math.tan(vfovRad/2);
          shot = estimateShotSize(frameH_m, state.actorHeightM);
        }
      }

      const sensorName = (SENSOR_DB[camObj.sensor]?.name || "Sensor");
      const lens = `${Math.round(camObj.focal)}mm`;
      const asp = state.storyboard.aspect.toFixed(2);

      let right = `${sensorName} • ${lens} • HFOV ${hfov.toFixed(1)}°`;
      if(distM !== null){
        right += ` • Dist ${distM.toFixed(2)}m • ${shot}`;
      }

      ctx.fillStyle = "rgba(255,255,255,0.88)";
      ctx.font = "12px ui-sans-serif, system-ui, -apple-system";
      ctx.textAlign = "left";
      ctx.fillText(`CAM: ${camObj.label}   |   Aspect ${asp}:1`, 10, 18);

      ctx.textAlign = "right";
      ctx.fillText(right, W - 10, 18);

      // corners in active rect
      ctx.strokeStyle = "rgba(255,163,0,0.30)";
      ctx.lineWidth = 2;
      drawCorners(ctx, active);
    }
  }

  function roundRect(ctx, x, y, w, h, r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  function drawCorners(ctx, rect){
    const m = 10, len = 18;
    const x = rect.x, y = rect.y, W = rect.w, H = rect.h;
    ctx.beginPath();
    // TL
    ctx.moveTo(x+m, y+m+len); ctx.lineTo(x+m, y+m); ctx.lineTo(x+m+len, y+m);
    // TR
    ctx.moveTo(x+W-m-len, y+m); ctx.lineTo(x+W-m, y+m); ctx.lineTo(x+W-m, y+m+len);
    // BL
    ctx.moveTo(x+m, y+H-m-len); ctx.lineTo(x+m, y+H-m); ctx.lineTo(x+m+len, y+H-m);
    // BR
    ctx.moveTo(x+W-m-len, y+H-m); ctx.lineTo(x+W-m, y+H-m); ctx.lineTo(x+W-m, y+H-m-len);
    ctx.stroke();
  }

  // ---------- Storyboard UI ----------
  const storyboardCache = new Map();

  function safeFile(name){
    return (name || "Camera").replace(/[^\w\- ]+/g, "").trim().replace(/\s+/g, "_").slice(0, 50) || "Camera";
  }

  function canvasToBlob(canvas){
    return new Promise((res) => canvas.toBlob((b) => res(b), "image/png"));
  }

  function exportStoryboard(){
    el.storyboardModal.classList.remove("hidden");
    el.storyboardModal.classList.add("flex");

    const cams = state.objects.filter(o => o.type === "camera" && !o.isGhost);
    if(cams.length === 0){
      el.storyboardGrid.innerHTML = `<div class="text-center text-xs text-red-300 py-10">Nessuna camera trovata nella scena.</div>`;
      return;
    }

    storyboardCache.clear();

    el.storyboardGrid.className = "p-6 overflow-y-auto grid grid-cols-1 md:grid-cols-2 gap-4";
    el.storyboardGrid.innerHTML = "";

    cams.forEach((cam, idx) => {
      const card = document.createElement("div");
      card.className = "storyboard-frame p-3 flex flex-col gap-2";

      const title = document.createElement("div");
      title.className = "flex items-center justify-between text-xs";
      title.innerHTML = `
        <div class="text-brand font-bold"><i class="fa-solid fa-video mr-2"></i>${cam.label}</div>
        <div class="text-[10px] opacity-60">Frame ${idx+1}</div>
      `;

      const canvas = document.createElement("canvas");
      canvas.className = "pov-canvas";
      // monitor-like: ALWAYS 16:9, letterbox inside for 2.39/1.85
      canvas.width = 960;
      canvas.height = 540;

      const actions = document.createElement("div");
      actions.className = "flex gap-2 justify-end pt-1";
      actions.innerHTML = `
        <button class="px-3 py-2 rounded-xl bg-white/5 hover:bg-white/10 text-[10px] font-bold" data-dl="${cam.id}">
          <i class="fa-solid fa-download mr-2"></i>PNG
        </button>
        <button class="px-3 py-2 rounded-xl bg-brand/10 border border-brand/20 hover:bg-brand hover:text-black text-brand text-[10px] font-bold transition" data-jump="${cam.id}">
          <i class="fa-solid fa-location-crosshairs mr-2"></i>FOCUS
        </button>
      `;

      card.appendChild(title);
      card.appendChild(canvas);
      card.appendChild(actions);
      el.storyboardGrid.appendChild(card);

      cameraPOVRenderToCanvas(cam, canvas);

      storyboardCache.set(cam.id, { cam, canvas });

      actions.querySelector(`[data-dl="${cam.id}"]`).addEventListener("click", async () => {
        const b = await canvasToBlob(canvas);
        saveAs(b, `${safeFile(cam.label)}_POV.png`);
      });

      actions.querySelector(`[data-jump="${cam.id}"]`).addEventListener("click", () => {
        focusOnObject(cam.id);
      });
    });
  }

  async function downloadStoryboardZip(){
    const items = [...storyboardCache.values()];
    if(items.length === 0) return;

    const zip = new JSZip();
    const folder = zip.folder(safeFile(state.sceneName || "Scene"));

    for(const item of items){
      const blob = await canvasToBlob(item.canvas);
      folder.file(`${safeFile(item.cam.label)}_POV.png`, blob);
    }

    const out = await zip.generateAsync({ type: "blob" });
    saveAs(out, `${safeFile(state.sceneName || "Scene")}_Storyboard.zip`);
  }

  function closeStoryboard(){
    el.storyboardModal.classList.add("hidden");
    el.storyboardModal.classList.remove("flex");
  }

  function focusOnObject(id){
    const o = getObject(id);
    if(!o) return;
    const target = worldToScreen(o.x, o.y);
    state.view.panX += (window.innerWidth/2 - target.x);
    state.view.panY += (window.innerHeight/2 - target.y);
    updateTransform();
    selectObject(id);
    markDirty({lines:true, meas:true});
  }

  // ---------- Project Settings ----------
  function openProjectSettings(){
    el.ppmInput.value = String(state.pxPerMeter);
    el.aspectSelect.value = String(state.storyboard.aspect);
    el.overlaysToggle.checked = !!state.storyboard.overlays;

    el.projectSettings.classList.remove("hidden");
    el.projectSettings.classList.add("flex");
  }

  function closeProjectSettings(){
    el.projectSettings.classList.add("hidden");
    el.projectSettings.classList.remove("flex");
  }

  function applyProjectSettings(){
    state.pxPerMeter = clamp(Number(el.ppmInput.value || 100), 10, 500);
    state.storyboard.aspect = clamp(Number(el.aspectSelect.value || 2.39), 1.0, 3.0);
    state.storyboard.overlays = !!el.overlaysToggle.checked;

    saveState();
    closeProjectSettings();
  }

  // ---------- UI actions ----------
  function wireActions(){
    document.addEventListener("click", (e) => {
      const btn = e.target.closest("[data-action]");
      if(!btn) return;

      const a = btn.getAttribute("data-action");
      const actions = {
        toggleSceneMenu: openSceneMenu,
        createNewScene,
        undo,
        redo,
        toggleMeasurements,
        toggleLayers,
        exportStoryboard,
        playScene,
        takeSnapshot,
        openInspector,
        closeInspector,
        addGhostPath,
        deleteSelected,
        openPropPicker,
        closeTimeline,
        closeStoryboard,
        downloadStoryboardZip,
        toggleSnap,
        activateTargetMode,
        openProjectSettings,
        closeProjectSettings,
        applyProjectSettings,
        addActor: () => addObject("actor", { label:"Actor", color:"#f43f5e" }),
        addCamera: () => addObject("camera", { label:"CAM", sensor:"FF", focal:35 }),
        saveScene,
      };
      if(actions[a]) actions[a]();
    });

    // Backdrops
    el.sceneMenu.addEventListener("click", (ev) => { if(ev.target === el.sceneMenu) closeSceneMenu(); });
    el.storyboardModal.addEventListener("click", (ev) => { if(ev.target === el.storyboardModal) closeStoryboard(); });
    el.propPicker.addEventListener("click", (ev) => { if(ev.target === el.propPicker) closePropPicker(); });
    el.projectSettings.addEventListener("click", (ev) => { if(ev.target === el.projectSettings) closeProjectSettings(); });

    // Prop categories
    document.querySelectorAll("[data-prop-cat]").forEach(b => {
      b.addEventListener("click", () => filterProps(b.getAttribute("data-prop-cat")));
    });

    // Inspector inputs
    el.inspName.addEventListener("input", () => updateLabel(el.inspName.value));
    el.inspName.addEventListener("change", () => saveState());

    el.inspLayer.addEventListener("change", () => updateLayer(el.inspLayer.value));

    el.colorPicker.addEventListener("input", () => setColor(el.colorPicker.value));
    el.colorPicker.addEventListener("change", () => saveState());
    document.querySelectorAll("[data-color]").forEach(b => {
      b.addEventListener("click", () => { setColor(b.getAttribute("data-color")); saveState(); });
    });

    // Lens controls
    el.sensorSelect.addEventListener("change", updateLensFromInspector);
    el.focalInput.addEventListener("change", updateLensFromInspector);

    el.fovSlider.addEventListener("input", () => {
      el.fovValue.textContent = el.fovSlider.value;
    });
    el.fovSlider.addEventListener("change", () => updateFovOverride(el.fovSlider.value));
  }

  function wireKeyboard(){
    document.addEventListener("keydown", (e) => {
      const isTyping = e.target && (e.target.matches("input, textarea") || e.target.isContentEditable);

      if((e.ctrlKey || e.metaKey) && !isTyping){
        if(e.key.toLowerCase() === "z" && !e.shiftKey){ e.preventDefault(); undo(); }
        else if((e.key.toLowerCase() === "z" && e.shiftKey) || e.key.toLowerCase() === "y"){ e.preventDefault(); redo(); }
      }

      if((e.key === "Delete" || e.key === "Backspace") && !isTyping){
        if(state.selectedId){ e.preventDefault(); deleteSelected(); }
      }

      if(e.key === "Escape"){
        if(!el.storyboardModal.classList.contains("hidden")) closeStoryboard();
        if(!el.sceneMenu.classList.contains("hidden")) closeSceneMenu();
        if(!el.propPicker.classList.contains("hidden")) closePropPicker();
        if(!el.projectSettings.classList.contains("hidden")) closeProjectSettings();
        closeInspector();
        document.body.style.cursor = "default";
        state.targetMode = false;
      }
    });
  }

  // ---------- Layer UI ----------
  function applyLayerVisibilityIcons(){
    [1,2,3].forEach(l => {
      const eye = document.getElementById(`layer-eye-${l}`);
      if(!eye) return;
      eye.className = state.layerVisibility[l] ? "fa-solid fa-eye text-xs opacity-60" : "fa-solid fa-eye-slash text-xs opacity-60";
    });
  }

  // ---------- Timeline scrub (UI) ----------
  function wireTimeline(){
    el.timelineScrubber.addEventListener("pointerdown", (ev) => {
      const rect = el.timelineScrubber.getBoundingClientRect();
      const x = clamp((ev.clientX - rect.left) / rect.width, 0, 1);
      el.timelineScrubber.style.background = `linear-gradient(to right, var(--brand) ${x*100}%, transparent ${x*100}%)`;
      el.timelinePlayhead.style.left = `calc(${x*100}% - 8px)`;
    });
  }

  // ---------- Boot ----------
  function init(){
    centerView();
    updateTransform();

    filterProps("light");

    el.viewport.addEventListener("pointerdown", onViewportPointerDown);
    el.viewport.addEventListener("pointermove", onViewportPointerMove);
    el.viewport.addEventListener("pointerup", onViewportPointerUp);
    el.viewport.addEventListener("pointercancel", onViewportPointerCancel);

    window.addEventListener("resize", () => markDirty({lines:true, meas:true}));

    wireActions();
    wireKeyboard();
    wireTimeline();

    // Start history
    saveState();
    loadSceneList();
    updateTopButtonsState();

    requestTick();
  }

  init();

})();
</script>
</body>
</html>
